require 'set'

class String
  def humanize
    str = sub(/^[0-9]*_/, '').sub("_", " ")
    return str[0].upcase + str[1..-1]
  end
end

module Jekyll
  class Document
    attr_accessor :toc
    alias old_url url
    alias old_to_liquid to_liquid
    
    def url
      return old_url unless @toc
      
      # it is a toc document, so process it
      return "/" + File.join(@toc.prefix, "index.html") unless not @toc.position.empty?
      return "/" + File.join(@toc.prefix, @toc.position.map{ |p| p.to_i }.join("/"), "index.html")
    end
    
  end
end

module TOC
  TOC_TYPE = "toc_type"
  TOC_OVERVIEW = "overview"
  TOC_KEY = "toc_key"
  
  class TocNode
    attr_reader :children
    attr_accessor :doc, :next, :prev, :src_id, :position, :parent, :prefix
    
    def initialize(src_id)
      @src_id = src_id
      @children = []
      @position = []
    end
    
    def to_liquid
      hash = {}
      hash["doc"] = @doc
      hash["next"] = @next.doc unless @next.nil?
      hash["prev"] = @prev.doc unless @prev.nil?
      hash["up"] = @parent.doc unless @parent.nil?
      hash["next_url"] = @next.doc.url unless @next.nil?
      hash["prev_url"] = @prev.doc.url unless @prev.nil?
      hash["up_url"] = @parent.doc.url unless @parent.nil?
      hash["position"] = @position
      hash["sec"] = sec
      hash["nice_sec"] = nice_sec
      hash["children"] = @children.map{ |c| c.doc }
           
      hash
    end
    
    def nice_sec
      return "" unless not position.empty?
      return "Chapter #{@position[0]}" unless position.length != 1
      return "Section #{sec}"
    end
    
    def sec
      @position.map{|p| p.to_i}.join(".")
    end
    
    def add_child(child)
      @children << child
      child.parent = self
    end
    
    def total_dst_ar
      @parent ? @parent.total_dst_ar << @dst_id : []     
    end
    
    def total_src_ar
      @parent ? @parent.total_src_ar << @src_id : []     
    end   
  end
  
    
  #def self.positionsToString(positions)
    #return positions.map{|i| i.to_s + "."}.join("")
  #end
  
  class SingleTOCGenerator 
    @collection_name
    
    def is_index_doc(doc)
      doc.data.fetch(TOC_TYPE, "") == TOC_OVERVIEW
    end
      
    def src_id_ar(doc)
      keys = doc.relative_path.sub(/^_#{@collection}\//, '').split("/")
      is_index_doc(doc) ? keys[0 .. -2] : keys
    end
    
    def autogenerated_name(node)
      if node.parent
        return node.src_id.humanize
      else
        return @config['root_title'] || "Table of contents"
      end
    end
    
    def generate_doc(node, site, coll, toc_indexpage)
      doc = Jekyll::Document.new(toc_indexpage, {site: site, collection: coll})
      doc.read
      coll.docs << doc
      
      # extract the title
      doc.data['title'] = autogenerated_name(node)
      
      node.doc = doc
    end
    
    def set_node_doc_data(node, prefix)
      node.prefix = prefix
      node.doc.toc = node
      node.doc.data['toc'] = node.to_liquid
    end
    
    def initialize(site, name, config)
      @config = config
      @collection_name = name
      collection = site.collections[config['collection']]
      
      # get the array of nodes for this collection
      node_ar = create_node_array(collection.docs)
      
      # construct the path to the toc_indexfile
      toc_template = File.join(site.config['source'], config['template'])
      
      # generate the "no"-docs
      node_ar.select { |n| n.doc.nil? }.each { |n| generate_doc(n, site, collection, toc_template) }
      
      # set the data
      node_ar.each { |n| set_node_doc_data(n, @config['prefix']) }
      
      # and a root node for this collection
      site.data['toc'][@collection_name]['root_doc'] = node_ar[0].doc
    end
    
    def create_node_array(docs)
      # hash with existing keys
      key_doc = Hash[ docs.map { |doc| [src_id_ar(doc)[1 .. -1  ], doc] }.to_a ]
      
      # add nils for new keys
      key_doc.keys.flat_map{ |key|  (0 .. key.length).map { |i| key[0 ... i] } }.each { |key| key_doc[key] = key_doc[key] }
      
      node_ar = []
      key_node_hash = {}
      
      key_doc.keys.sort {|a,b| a.join("/") <=> b.join("/") }.each do |key| 
        # create a node in the hash
        node = key_node_hash[key] = TocNode.new( key.empty? ? nil : key[-1] )
        
        # get the parent
        parent = key_node_hash[key[0..-2]] unless key.empty?
      
        
        # set the child relationship
        parent.add_child(node) unless parent.nil?
        
        # set all the keys
        node.doc = key_doc[key]
        node.prev = node_ar[-1] unless node_ar.empty?
        node_ar[-1].next = node unless node_ar.empty?
        node.position = parent.position + [parent.children.length] unless parent.nil?
        
        # add to the list
        node_ar << node
      end
      
      node_ar
    end
  end
  
  class TOCGenerator < Jekyll::Generator
    def generate(site)
    
      if site.data['toc'].nil?
        return
      end
      
      for key,value in site.data['toc']
        value["collection"] = key unless value["collection"]
        value["prefix"] = key unless value["prefix"]
        
        if value["template"].nil?
          raise("No TOC template defined for '#{key}'")
        end
        
        value["root_title"] = "Table of contents" unless value["root_title"]
        
        
        SingleTOCGenerator.new(site, key, value)
        
      end
    end
  end
end
